// -*- mode: C++; indent-tabs-mode: nil; c-basic-offset: 4 -*-

/*
 * (c) 2016-2019 Vladimír Štill <xstill@fi.muni.cz>
 */

/* Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE. */

#include <brick-except>
#include <brick-fs>
#include <brick-string>

#include <string>
#include <vector>
#include <algorithm>
#include <iterator>
#include <sstream>
#include <iostream>
#include <future>
#include <memory>
#include <optional>
#include <variant>
#include <chrono>

#if defined( __unix__ ) || defined( __divine__ )
#include <termios.h>
#include <unistd.h>
#include <signal.h>
#include <spawn.h>
#include <sys/wait.h>
#include <sys/epoll.h>
#endif

#ifndef BRICK_PROC
#define BRICK_PROC

namespace brick {
namespace proc {

// like waitpid, but with timeout, using sigtimewait, option should not be WNOHANG
// returns 0 & errno = EAGAIN if timeout passed
// returns output of sigtimewait it if fails (except if it EINTR's, then it repeats)
// otherwise returns return value of waitpid with additional WNOHANG
template< typename Rep, typename Period >
int timewaitpid( pid_t pid, int *stat_loc, int options, std::chrono::duration< Rep, Period > timeout )
{
    namespace ch = std::chrono;
    auto start = ch::steady_clock::now();
    auto end = start + timeout;
    siginfo_t info;
    struct timespec tout;
    sigset_t chldset;
    ::sigemptyset( &chldset );
    ::sigaddset( &chldset, SIGCHLD );
    int swr;

    do {
        auto timeout = end - ch::steady_clock::now();
        tout.tv_sec = ch::duration_cast< ch::seconds >( timeout ).count();
        tout.tv_nsec = ch::duration_cast< ch::nanoseconds >( timeout ).count()
                       % 1000'000'000;
        int swr = ::sigtimedwait( &chldset, &info, &tout );
        if ( swr < 0 && errno != EINTR )
            return errno == EAGAIN ? 0 : 1;
        if ( info.si_pid == pid )
            return ::waitpid( pid, stat_loc, options | WNOHANG );
    } while ( timeout > ch::nanoseconds( 0 ) );
    errno = EAGAIN;
    return 0;
}

struct ProcError : brick::except::Error
{
    using brick::except::Error::Error;
};

enum SpawnOptsEnum : unsigned {
    None = 0,
    CaptureStdout = 0x1,
    CaptureStderr = 0x2,
    ShowCmd = 0x100
};

struct SpawnOpts {
    SpawnOpts( SpawnOptsEnum f ) : flags( f ) { }
    SpawnOpts( unsigned f ) : flags( SpawnOptsEnum( f ) ) { }
    SpawnOpts() = default;

    bool hasFlag( SpawnOptsEnum f ) const { return (flags & f) == f; }

    std::optional< std::string > in;
    std::optional< std::string > work_dir;
    std::optional< std::chrono::milliseconds > timeout;
    int extraFDs = 0;
    SpawnOptsEnum flags = None;
};

inline SpawnOpts StdinString( std::string in ) {
    SpawnOpts so;
    so.in.emplace( std::move( in ) );
    return so;
}

inline SpawnOpts WorkDir( std::string wd ) {
    SpawnOpts so;
    so.work_dir.emplace( std::move( wd ) );
    return so;
}

inline SpawnOpts ExtraFDs( int num ) {
    SpawnOpts so;
    so.extraFDs = num;
    ASSERT_LEQ( 0, so.extraFDs );
    return so;

}

template< typename Rep, typename Period >
inline SpawnOpts Timeout( std::chrono::duration< Rep, Period > timeout ) {
    SpawnOpts so;
    so.timeout.emplace( std::chrono::duration_cast< std::chrono::milliseconds >( timeout ) );
    return so;
}

inline SpawnOpts operator|( SpawnOpts a, SpawnOpts b )
{
    auto merge = []( auto &a, auto &&b ) {
        ASSERT( !(a && b ) );
        if ( b )
            a = std::move( b );
    };
    a.flags = SpawnOptsEnum( a.flags | b.flags );
    merge( a.in, std::move( b.in ) );
    merge( a.work_dir, std::move( b.work_dir ) );
    merge( a.timeout, std::move( b.timeout ) );
    merge( a.extraFDs, std::move( b.extraFDs ) );
    return a;
}

struct SystemOutput {

    SystemOutput( int exitcode, int signal, std::chrono::milliseconds time, bool timeout,
                  std::vector< std::string > outs ) :
        _exitcode( exitcode ), _signal( signal ), _time( time ), _timeout( timeout ), _outFDs{ outs }
    {
        if ( _outFDs.size() < 2 )
            _outFDs.resize( 2 );
    }

    bool ok() const { return _exitcode == 0 && _signal == 0 && !_timeout; }
    explicit operator bool() const { return ok(); }

    int exitcode() const { return _exitcode; }
    int signal() const { return _signal; }
    bool timeout() const { return _timeout; }

    const std::string &out() const { return _outFDs[0]; }
    const std::string &err() const { return _outFDs[1]; }

    const std::string &out_fd( int fd ) const {
        ASSERT_LT( fd - 1, _outFDs.size() );
        return _outFDs[ fd - 1 ];
    }

    std::chrono::milliseconds time() const { return _time; }

  private:
    int _exitcode;
    int _signal;
    std::chrono::milliseconds _time;
    bool _timeout;
    std::vector< std::string > _outFDs; // starts with FD 1
};

inline namespace {

std::string to_string( const SystemOutput &o ) {
    std::stringstream ss;
    ss << "exitcode = " << o.exitcode() << ", signal = " << o.signal()
       << (o.timeout() ? ", timeout" : "")
       << ", took " << o.time().count() << "ms" << std::endl;
    for ( auto x : { std::make_pair( "stdout", &o.out() ), std::make_pair( "stderr", &o.err() ) } ) {
        if ( !x.second->empty() ) {
            ss << x.first << ":" << std::endl;
            std::stringstream data( *x.second );
            std::string line;
            while ( std::getline( data, line ) )
                ss << "    " << line << std::endl;
            ss << std::endl;
        }
    }
    return ss.str();
}

}

struct Pipe {
    Pipe() {
        if ( ::pipe2( _fds, O_CLOEXEC ) == -1 )
            throw ProcError( "could not create pipe" );
    }

    ~Pipe() { close(); }

    void close() {
        closeRead();
        closeWrite();
    }

    void _close( bool wr ) {
        int r = _fds[wr];
        _fds[wr] = -1;
        if ( r >= 0 )
            ::close( r );
    }
    void closeRead() { _close( false ); }
    void closeWrite() { _close( true ); }

    std::string drain() {
        std::string str;
        char data[ 1024 ];
        long n;
        do {
            n = ::read( read(), data, sizeof( data ) );
            if ( n > 0 )
                str += std::string( data, n );
        } while( n > 0 );
        return str;
    }

    void push( std::string s ) {
        const char *ptr = s.data();
        const char *const end = ptr + s.size();
        int r = 0;
        while ( ptr < end && r >= 0 ) {
            r = ::write( write(), ptr, end - ptr );
            ptr += r;
        }
    }

    int read() const { return _fds[0]; }
    int write() const { return _fds[1]; }

#ifdef __unix__
    Pipe &attach( bool wr, int to, bool close = false ) {
        if ( close )
            _close( !wr );
        int r = ::dup2( wr ? write() : read(), to );
        if ( r != _fds[ wr ] ) {
            if ( close )
                _close( wr );
        } else {
            int fgs = ::fcntl( r, F_GETFD );
            ASSERT_LEQ( 0, fgs );
            ::fcntl( r, F_SETFD, fgs & (~FD_CLOEXEC) );
        }
        return *this;
    }

    Pipe &attachWrite( int tofd, bool close = false ) { return attach( true, tofd, close ); }
    Pipe &attachRead( int tofd, bool close = false ) { return attach( false, tofd, close ); }

    Pipe &attachStdout( bool close = false ) { return attach( true, STDOUT_FILENO, close ); }
    Pipe &attachStderr( bool close = false ) { return attach( true, STDERR_FILENO, close ); }
    Pipe &attachStdin( bool close = false ) { return attach( false, STDIN_FILENO, close ); }
#else
#error attach* fuctions are not supporrted on this platfrom
#endif

  private:
    int _fds[2];
};

struct PollJob {
    static PollJob &get( void *pj ) { return *reinterpret_cast< PollJob * >( pj ); }

    PollJob( std::string &in ) : inout( std::in_place_type< std::string_view >, in ) { }
    PollJob() : inout( std::in_place_type< std::string > ) { }

    std::string &out() { return std::get< std::string >( inout ); }
    bool is_out() const { return std::holds_alternative< std::string >( inout ); }
    int fd() const { return is_out() ? pipe.read() : pipe.write(); }

    bool operator()( struct epoll_event &ev ) {
        return std::visit( [this, &ev]( auto &v ) { return handle( v, ev ); }, inout );
    }

    Pipe pipe;
  private:
    std::variant< std::string_view, std::string > inout;

    bool handle( std::string_view &in, struct epoll_event &ev ) {
        if ( in.empty() || (ev.events & (EPOLLERR | EPOLLHUP)) )
            return false;
        ASSERT( ev.events & EPOLLOUT );
        int size = ::write( pipe.write(), in.data(), in.size() );
        if ( size < 0 && errno != EINTR )
            throw ProcError( "write to stdin failed" );
        in.remove_prefix( size );
        return !in.empty();
    }

    bool handle( std::string &out, struct epoll_event &ev ) {
        ASSERT( ev.events & (EPOLLIN | EPOLLHUP) );
        int to_read = out.capacity() - out.size();
        if ( to_read == 0 ) {
            out.reserve( std::max( size_t( 16 ), 2 * out.capacity() ) );
            to_read = out.capacity() - out.size();
        }
        char *read_to = &*out.end();
        out.resize( out.capacity() );
        int size = ::read( pipe.read(), read_to, to_read );
        if ( size < 0 && errno != EINTR )
            throw ProcError( "read failed" );
        out.resize( out.size() - to_read + size );
        return size != 0;
    }
};

inline SystemOutput spawnAndWait( SpawnOpts opts, std::vector< std::string > args )
{
    if ( opts.hasFlag( ShowCmd ) ) {
        std::cerr << "+ ";
        std::copy( args.begin(), args.end(), std::ostream_iterator< std::string >( std::cerr, " " ) );
        std::cerr << std::endl;
    }
    std::vector< const char * > cargs;
    cargs.reserve( args.size() + 1 );
    std::transform( args.begin(), args.end(), std::back_inserter( cargs ),
                    []( const std::string &s ) { return s.c_str(); } );
    cargs.push_back( nullptr );
    std::string out, err;

#ifdef __unix__
    std::optional< PollJob > inp, outp, errp;
    std::vector< PollJob > extrap( opts.extraFDs );
    if ( opts.in )
        inp.emplace( opts.in.value() );
    if ( opts.hasFlag( CaptureStdout ) )
        outp.emplace();
    if ( opts.hasFlag( CaptureStderr ) )
        errp.emplace();

    pid_t pid;
    if ( (pid = ::fork()) == 0 ) {
        if ( inp )
            inp->pipe.attachStdin( true );
        if ( outp )
            outp->pipe.attachStdout( true );
        if ( errp )
            errp->pipe.attachStderr( true );
        for ( auto &extra : extrap )
            extra.pipe.attachWrite( 3 + (&*extrap.begin() - &extra), true );

        if ( opts.work_dir )
            brick::fs::chdir( opts.work_dir.value() );
        int r = ::setpgid( 0, 0 );
        ASSERT_EQ( 0, r );
        ASSERT_EQ( ::getpid(), getpgid( 0 ) );
        ::execvp( cargs[ 0 ], const_cast< char *const * >( cargs.data() ) );
        std::terminate();
    } else if ( pid > 0 ) {
        ::setpgid( pid, pid ); // see man setpgid

        fs::Fd epoll{ ::epoll_create1( EPOLL_CLOEXEC ) };
        int polling_cnt = 0;

        namespace ch = std::chrono;
        using namespace std::literals;

        auto start = ch::steady_clock::now();
        std::optional< ch::steady_clock::time_point > end_timeout;
        if ( opts.timeout )
            end_timeout.emplace( start + *opts.timeout );
        auto ms = []( auto t ) { return ch::duration_cast< ch::milliseconds >( t ); };

        if ( inp ) {
            inp->pipe.closeRead();
            struct epoll_event ev;
            ev.events = EPOLLOUT;
            ev.data.ptr = &*inp;
            int r = ::epoll_ctl( epoll.fd(), EPOLL_CTL_ADD, inp->fd(), &ev );
            if ( r != 0 )
                throw ProcError( "epoll failed for stdin" );
            ++polling_cnt;
        }
        auto epoll_reg_out = [&]( PollJob &p ) {
            p.pipe.closeWrite();
            struct epoll_event ev;
            ev.events = EPOLLIN;
            ev.data.ptr = &p;
            int r = ::epoll_ctl( epoll.fd(), EPOLL_CTL_ADD, p.fd(), &ev );
            if ( r != 0 )
                throw ProcError( "epoll failed for an output" );
            ++polling_cnt;
        };

        if ( outp )
            epoll_reg_out( *outp );
        if ( errp )
            epoll_reg_out( *errp );
        for ( auto &extra : extrap )
            epoll_reg_out( extra );

        bool timeout = false;
        while ( polling_cnt > 0 &&
                ( !end_timeout || !(timeout = (ch::steady_clock::now() >= *end_timeout)) ) )
        {
            struct epoll_event ev;
            int r = ::epoll_wait( epoll.fd(), &ev, 1, end_timeout
                              ? std::max( 0, int( ms( *end_timeout
                                                 - ch::steady_clock::now() ).count() ) )
                              : -1 );
            if ( r == 0 || (r < 0 && errno == EINTR) )
                continue;
            if ( r < 0 )
                throw ProcError( "epoll failed" );
            ASSERT_EQ( r, 1 );

            auto &job = PollJob::get( ev.data.ptr );
            if ( !job( ev ) ) {
                ::epoll_ctl( epoll.fd(), EPOLL_CTL_DEL, job.fd(), nullptr );
                job.pipe.close();
                --polling_cnt;
            }
        }

        std::vector< std::string > outs;
        if ( opts.hasFlag( CaptureStdout ) ) {
            outs.emplace_back( std::move( outp->out() ) );
            outp->pipe.close();
        }
        else
            outs.emplace_back();

        if ( opts.hasFlag( CaptureStderr ) ) {
            outs.emplace_back( std::move( errp->out() ) );
            errp->pipe.close();
        }
        else if ( opts.extraFDs > 0 )
            outs.emplace_back();

        for ( auto &p : extrap ) {
            outs.emplace_back( std::move( p.out() ) );
            p.pipe.close();
        }

        int status, r;
        if ( !timeout && end_timeout ) {
            r = timewaitpid( pid, &status, 0, *end_timeout - ch::steady_clock::now() );
            timeout = r == 0 && errno == EAGAIN;
        }
        if ( timeout ) {
            ::kill( -pid, SIGALRM );
            r = timewaitpid( pid, &status, 0, 100ms );
            if ( r == 0 ) {
                ::kill( -pid, SIGKILL );
                r = ::waitpid( pid, &status, 0 );
            }
        }
        else
            r = ::waitpid( pid, &status, 0 );
        if ( r < 0 )
            throw ProcError( "waitpid error" );
        return SystemOutput( WIFEXITED( status ) ? WEXITSTATUS( status ) : 0,
                             WIFSIGNALED( status ) ? WTERMSIG( status ) : 0,
                             ms( ch::steady_clock::now() - start ), timeout, outs );
    } else
        throw ProcError( "fork failed" );
#else
#error implementation of brick::proc::spawnAndWait for this platform is missing
#endif
}

inline SystemOutput spawnAndWait( std::vector< std::string > args ) {
    return spawnAndWait( None, args );
}

template< typename... Args >
SystemOutput spawnAndWait( SpawnOpts opts, Args &&...args ) {
    return spawnAndWait( opts, std::vector< std::string >{ std::forward< Args >( args )... } );
}

template< typename... Args >
SystemOutput spawnAndWait( SpawnOptsEnum opts, Args &&...args ) {
    return spawnAndWait( SpawnOpts( opts ), std::forward< Args >( args )... );
}

template< typename... Args >
SystemOutput spawnAndWait( unsigned opts, Args &&...args ) { // note: result of | on SpawnOptsEnum in unsigned
    return spawnAndWait( SpawnOpts( SpawnOptsEnum( opts ) ), std::forward< Args >( args )... );
}

template< typename... Args >
SystemOutput spawnAndWait( Args &&...args ) {
    return spawnAndWait( None, std::forward< Args >( args )... );
}

inline SystemOutput shellSpawnAndWait( SpawnOpts opts, std::string shellcmd ) {
#ifdef __unix__
    return spawnAndWait( opts, "/bin/sh", "-c", shellcmd );
#else
#error shell spawn is not supported on this platform
#endif
}

inline SystemOutput shellSpawnAndWait( std::string shellcmd ) {
    return shellSpawnAndWait( None, shellcmd );
}

struct XTerm
{
    struct
    {
        int pid = 0;
        int masterfd, slavefd;

        std::unique_ptr< std::iostream > stream;
        std::unique_ptr< brick::fs::PosixBuf > buf;
    } _d;

    struct SBuf : fs::PosixBuf
    {
        using fs::PosixBuf::PosixBuf;

        int sync()
        {
            char tmp[ _buf_size * 2 ];
            int i = 0;
            for ( auto p = pbase(); p < pptr(); ++p )
            {
                if ( *p == '\n' )
                    tmp[ i++ ] = '\r';
                tmp[ i++ ] = *p;
            }
            do_sync( tmp, i );
            return 0;
        }
    };

    void open()
    {
        _d.masterfd = posix_openpt( O_RDWR );
        if ( grantpt( _d.masterfd ) )
            throw std::system_error( errno, std::system_category(),
                                     "Could not grantpt()." );
        if ( unlockpt( _d.masterfd ) )
            throw std::system_error( errno, std::system_category(),
                                     "Could not unlockpt()." );

        const char *slavepts = ptsname( _d.masterfd );
        if ( !slavepts )
            throw std::system_error( errno, std::system_category(),
                                     "Could not ptsname()." );
        _d.slavefd = ::open( slavepts, O_RDWR );
        if ( _d.slavefd < 0 )
            throw std::system_error( errno, std::system_category(),
                                     "Could not open slave PTS." );

        std::string slave = std::string( "-S" ) +
                            slavepts + "/" + brick::string::fmt( _d.slavefd );
        const char *argv[] = { "xterm", slave.c_str(), nullptr };

        posix_spawnp( &_d.pid, "xterm", nullptr, nullptr,
                      const_cast< char ** >( argv ), environ );

        char buf[8];
        ::read( _d.masterfd, buf, 8 ); /* handshake */

        struct termios tio;
        tcgetattr( _d.slavefd, &tio );
        tio.c_lflag = 0; /* no ECHO means we don't read things back */
        tio.c_iflag = 0;
        tio.c_oflag = 0;
        tcsetattr( _d.slavefd, TCSANOW, &tio );

        _d.buf.reset( new SBuf( _d.masterfd ) );
        _d.stream.reset( new std::iostream( _d.buf.get() ) );
    }

    std::iostream &stream() { return *_d.stream; }

    XTerm() = default;
    XTerm( const XTerm & ) = delete;
    XTerm( XTerm &&o )
    {
        _d = std::move( o._d );
        o._d.pid = 0;
    }

    ~XTerm()
    {
        if ( _d.pid )
        {
            kill( _d.pid, SIGTERM );
            close( _d.masterfd );
            close( _d.slavefd );
            waitpid( _d.pid, nullptr, 0 );
        }
        _d.pid = 0;
    }
};

}

namespace t_proc {
using namespace std::literals;

struct TestSpawn {
    TEST( basic_true ) {
        auto r = proc::spawnAndWait( "true" );
        ASSERT_EQ( r.exitcode(), 0 );
        ASSERT_EQ( r.signal(), 0 );
        ASSERT( r );
    }

    TEST( basic_false ) {
        auto r = proc::spawnAndWait( "false" );
        ASSERT_LT( 0, r.exitcode() );
        ASSERT_EQ( r.signal(), 0 );
        ASSERT( !r );
    }

    TEST( echo1 ) {
        auto r = proc::spawnAndWait( proc::CaptureStdout, "printf", "a" );
        ASSERT( r );
        ASSERT_EQ( r.out(), "a" );
        ASSERT_EQ( r.err(), "" );
    }

    TEST( echo2 ) {
        auto r = proc::spawnAndWait( proc::CaptureStdout | proc::CaptureStderr, "printf", "a" );
        ASSERT( r );
        ASSERT_EQ( r.out(), "a" );
        ASSERT_EQ( r.err(), "" );
    }

    TEST( echoSpec ) {
        auto r = proc::spawnAndWait( proc::CaptureStdout, "printf", "a\nb" );
        ASSERT( r );
        ASSERT_EQ( r.out(), "a\nb" );
        ASSERT_EQ( r.err(), "" );
    }

    TEST( shellEchoStdout ) {
        auto r = proc::shellSpawnAndWait( proc::CaptureStdout, "printf a" );
        ASSERT( r );
        ASSERT_EQ( r.out(), "a" );
        ASSERT_EQ( r.err(), "" );
    }

    TEST( shellEchoStderr ) {
        auto r = proc::shellSpawnAndWait( proc::CaptureStdout | proc::CaptureStderr, "printf a >&2" );
        ASSERT( r );
        ASSERT_EQ( r.out(), "" );
        ASSERT_EQ( r.err(), "a" );
    }

    TEST( in_basic ) {
        auto r = proc::spawnAndWait( proc::StdinString( "abcbd" ) | proc::CaptureStdout | proc::CaptureStderr,
                                     "sed", "s/b/x/g" );
        ASSERT( r );
        ASSERT_EQ( r.out(), "axcxd" );
        ASSERT_EQ( r.err(), "" );
    }
    TEST( in_lined ) {
        auto r = proc::spawnAndWait( proc::StdinString( "abcbd\nebfg\n" ) | proc::CaptureStdout | proc::CaptureStderr,
                                     "sed", "s/b/x/g" );
        ASSERT( r );
        ASSERT_EQ( r.out(), "axcxd\nexfg\n" );
        ASSERT_EQ( r.err(), "" );
    }

    TEST( extra_out ) {
        auto r = proc::spawnAndWait( proc::CaptureStdout | proc::ExtraFDs( 1 ),
                                     "perl", "-e", R".(
                open(my $h, '>&=3') or die "$!";
                print $h 'xay';
                print "a"
            )." );
        ASSERT( r );
        ASSERT_EQ( r.out(), "a" );
        ASSERT_EQ( r.err(), "" );
        ASSERT_EQ( r.out_fd( 3 ), "xay" );
    }
    TEST( extra_out_shell ) {
        auto r = proc::shellSpawnAndWait( proc::CaptureStdout | proc::ExtraFDs( 1 ) | proc::StdinString( "abcdefg" ),
                                          "sed 's/cd/xz/' >&3" );
        ASSERT( r );
        ASSERT_EQ( r.out(), "" );
        ASSERT_EQ( r.err(), "" );
        ASSERT_EQ( r.out_fd( 3 ), "abxzefg" );
    }

    TEST( timeout_bash ) {
        ::alarm( 5 );
        auto r = proc::shellSpawnAndWait( proc::Timeout( 500ms ), "while true; do :; done" );
        ::alarm( 0 );
        ASSERT( !r );
        ASSERT( r.timeout() );
    }
    TEST( timeout_noalrm ) {
        ::alarm( 5 );
        auto r = proc::spawnAndWait( proc::Timeout( 500ms ), "perl", "-e", R".(
                $SIG{ALRM} = "IGNORE";
                while ( true ) { }
            )." );
        ::alarm( 0 );
        ASSERT( !r );
        ASSERT( r.timeout() );
    }
    TEST( timeout_threads ) {
        auto loop = R".(
            $| = 1; # force flushing
            while ( true ) {
                print "x";
                select( undef, undef, undef, 0.1 );
            }).";
        ::alarm( 10 );
        auto other = std::async( std::launch::async, [&] {
            return proc::spawnAndWait( proc::CaptureStdout | proc::Timeout( 3s ), "perl", "-e", loop ); } );
        auto r1 = proc::spawnAndWait( proc::CaptureStdout | proc::Timeout( 1s ), "perl", "-e", loop );
        auto r2 = other.get();
        ::alarm( 0 );
        ASSERT( !r1 );
        ASSERT( !r2 );
        ASSERT( r1.timeout() );
        ASSERT( r2.timeout() );
        // assume 500ms for delays & perl
        ASSERT( 500ms <= r1.time() );
        ASSERT( r1.time() <= 1500ms );
        ASSERT( 2500ms <= r2.time() );
        ASSERT( r2.time() <= 3500ms );

        ASSERT_LEQ( 5, r1.out().size() );
        ASSERT_LEQ( r1.out().size(), 15 );
        ASSERT_LEQ( 25, r2.out().size() );
        ASSERT_LEQ( r2.out().size(), 35 );
    }

    TEST( timeout_group ) {
        ::alarm( 10 );
        auto my_pid = ::getpid();
        auto r = proc::shellSpawnAndWait( proc::Timeout( 1s ),
                    "perl -e '$SIG{ALRM} = \"IGNORE\"; sleep 2; kill \"USR1\", "
                          + std::to_string( my_pid ) + "' &" );
        ::sleep( 2 ); // wait if we receive SIGUSR1 and it kills us
        ::alarm( 0 );
    }
};

};

}

#endif // BRICK_PROC

// vim: syntax=cpp tabstop=4 shiftwidth=4 expandtab ft=cpp
